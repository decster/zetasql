// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zetasql/compliance/test_driver.proto

#ifndef PROTOBUF_INCLUDED_zetasql_2fcompliance_2ftest_5fdriver_2eproto
#define PROTOBUF_INCLUDED_zetasql_2fcompliance_2ftest_5fdriver_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "zetasql/public/annotation.pb.h"
#include "zetasql/public/options.pb.h"
#include "zetasql/public/type.pb.h"
#include "zetasql/public/value.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_zetasql_2fcompliance_2ftest_5fdriver_2eproto 

namespace protobuf_zetasql_2fcompliance_2ftest_5fdriver_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_zetasql_2fcompliance_2ftest_5fdriver_2eproto
namespace zetasql {
class TestDatabaseProto;
class TestDatabaseProtoDefaultTypeInternal;
extern TestDatabaseProtoDefaultTypeInternal _TestDatabaseProto_default_instance_;
class TestTableOptionsProto;
class TestTableOptionsProtoDefaultTypeInternal;
extern TestTableOptionsProtoDefaultTypeInternal _TestTableOptionsProto_default_instance_;
class TestTableProto;
class TestTableProtoDefaultTypeInternal;
extern TestTableProtoDefaultTypeInternal _TestTableProto_default_instance_;
class TypeAndValue;
class TypeAndValueDefaultTypeInternal;
extern TypeAndValueDefaultTypeInternal _TypeAndValue_default_instance_;
}  // namespace zetasql
namespace google {
namespace protobuf {
template<> ::zetasql::TestDatabaseProto* Arena::CreateMaybeMessage<::zetasql::TestDatabaseProto>(Arena*);
template<> ::zetasql::TestTableOptionsProto* Arena::CreateMaybeMessage<::zetasql::TestTableOptionsProto>(Arena*);
template<> ::zetasql::TestTableProto* Arena::CreateMaybeMessage<::zetasql::TestTableProto>(Arena*);
template<> ::zetasql::TypeAndValue* Arena::CreateMaybeMessage<::zetasql::TypeAndValue>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace zetasql {

// ===================================================================

class TestDatabaseProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.TestDatabaseProto) */ {
 public:
  TestDatabaseProto();
  virtual ~TestDatabaseProto();

  TestDatabaseProto(const TestDatabaseProto& from);

  inline TestDatabaseProto& operator=(const TestDatabaseProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestDatabaseProto(TestDatabaseProto&& from) noexcept
    : TestDatabaseProto() {
    *this = ::std::move(from);
  }

  inline TestDatabaseProto& operator=(TestDatabaseProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestDatabaseProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestDatabaseProto* internal_default_instance() {
    return reinterpret_cast<const TestDatabaseProto*>(
               &_TestDatabaseProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TestDatabaseProto* other);
  friend void swap(TestDatabaseProto& a, TestDatabaseProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestDatabaseProto* New() const final {
    return CreateMaybeMessage<TestDatabaseProto>(NULL);
  }

  TestDatabaseProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestDatabaseProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestDatabaseProto& from);
  void MergeFrom(const TestDatabaseProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDatabaseProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string proto_files = 1;
  int proto_files_size() const;
  void clear_proto_files();
  static const int kProtoFilesFieldNumber = 1;
  const ::std::string& proto_files(int index) const;
  ::std::string* mutable_proto_files(int index);
  void set_proto_files(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_proto_files(int index, ::std::string&& value);
  #endif
  void set_proto_files(int index, const char* value);
  void set_proto_files(int index, const char* value, size_t size);
  ::std::string* add_proto_files();
  void add_proto_files(const ::std::string& value);
  #if LANG_CXX11
  void add_proto_files(::std::string&& value);
  #endif
  void add_proto_files(const char* value);
  void add_proto_files(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& proto_files() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_proto_files();

  // repeated string proto_names = 3;
  int proto_names_size() const;
  void clear_proto_names();
  static const int kProtoNamesFieldNumber = 3;
  const ::std::string& proto_names(int index) const;
  ::std::string* mutable_proto_names(int index);
  void set_proto_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_proto_names(int index, ::std::string&& value);
  #endif
  void set_proto_names(int index, const char* value);
  void set_proto_names(int index, const char* value, size_t size);
  ::std::string* add_proto_names();
  void add_proto_names(const ::std::string& value);
  #if LANG_CXX11
  void add_proto_names(::std::string&& value);
  #endif
  void add_proto_names(const char* value);
  void add_proto_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& proto_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_proto_names();

  // repeated string enum_names = 4;
  int enum_names_size() const;
  void clear_enum_names();
  static const int kEnumNamesFieldNumber = 4;
  const ::std::string& enum_names(int index) const;
  ::std::string* mutable_enum_names(int index);
  void set_enum_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_enum_names(int index, ::std::string&& value);
  #endif
  void set_enum_names(int index, const char* value);
  void set_enum_names(int index, const char* value, size_t size);
  ::std::string* add_enum_names();
  void add_enum_names(const ::std::string& value);
  #if LANG_CXX11
  void add_enum_names(::std::string&& value);
  #endif
  void add_enum_names(const char* value);
  void add_enum_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& enum_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_enum_names();

  // repeated .zetasql.TestTableProto test_tables = 5;
  int test_tables_size() const;
  void clear_test_tables();
  static const int kTestTablesFieldNumber = 5;
  ::zetasql::TestTableProto* mutable_test_tables(int index);
  ::google::protobuf::RepeatedPtrField< ::zetasql::TestTableProto >*
      mutable_test_tables();
  const ::zetasql::TestTableProto& test_tables(int index) const;
  ::zetasql::TestTableProto* add_test_tables();
  const ::google::protobuf::RepeatedPtrField< ::zetasql::TestTableProto >&
      test_tables() const;

  // optional bool runs_as_test = 2;
  bool has_runs_as_test() const;
  void clear_runs_as_test();
  static const int kRunsAsTestFieldNumber = 2;
  bool runs_as_test() const;
  void set_runs_as_test(bool value);

  // @@protoc_insertion_point(class_scope:zetasql.TestDatabaseProto)
 private:
  void set_has_runs_as_test();
  void clear_has_runs_as_test();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> proto_files_;
  ::google::protobuf::RepeatedPtrField< ::std::string> proto_names_;
  ::google::protobuf::RepeatedPtrField< ::std::string> enum_names_;
  ::google::protobuf::RepeatedPtrField< ::zetasql::TestTableProto > test_tables_;
  bool runs_as_test_;
  friend struct ::protobuf_zetasql_2fcompliance_2ftest_5fdriver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestTableOptionsProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.TestTableOptionsProto) */ {
 public:
  TestTableOptionsProto();
  virtual ~TestTableOptionsProto();

  TestTableOptionsProto(const TestTableOptionsProto& from);

  inline TestTableOptionsProto& operator=(const TestTableOptionsProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestTableOptionsProto(TestTableOptionsProto&& from) noexcept
    : TestTableOptionsProto() {
    *this = ::std::move(from);
  }

  inline TestTableOptionsProto& operator=(TestTableOptionsProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestTableOptionsProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestTableOptionsProto* internal_default_instance() {
    return reinterpret_cast<const TestTableOptionsProto*>(
               &_TestTableOptionsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TestTableOptionsProto* other);
  friend void swap(TestTableOptionsProto& a, TestTableOptionsProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestTableOptionsProto* New() const final {
    return CreateMaybeMessage<TestTableOptionsProto>(NULL);
  }

  TestTableOptionsProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestTableOptionsProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestTableOptionsProto& from);
  void MergeFrom(const TestTableOptionsProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTableOptionsProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zetasql.LanguageFeature required_features = 5;
  int required_features_size() const;
  void clear_required_features();
  static const int kRequiredFeaturesFieldNumber = 5;
  ::zetasql::LanguageFeature required_features(int index) const;
  void set_required_features(int index, ::zetasql::LanguageFeature value);
  void add_required_features(::zetasql::LanguageFeature value);
  const ::google::protobuf::RepeatedField<int>& required_features() const;
  ::google::protobuf::RepeatedField<int>* mutable_required_features();

  // repeated .zetasql.AnnotationMapProto column_annotations = 7;
  int column_annotations_size() const;
  void clear_column_annotations();
  static const int kColumnAnnotationsFieldNumber = 7;
  ::zetasql::AnnotationMapProto* mutable_column_annotations(int index);
  ::google::protobuf::RepeatedPtrField< ::zetasql::AnnotationMapProto >*
      mutable_column_annotations();
  const ::zetasql::AnnotationMapProto& column_annotations(int index) const;
  ::zetasql::AnnotationMapProto* add_column_annotations();
  const ::google::protobuf::RepeatedPtrField< ::zetasql::AnnotationMapProto >&
      column_annotations() const;

  // optional string userid_column = 6;
  bool has_userid_column() const;
  void clear_userid_column();
  static const int kUseridColumnFieldNumber = 6;
  const ::std::string& userid_column() const;
  void set_userid_column(const ::std::string& value);
  #if LANG_CXX11
  void set_userid_column(::std::string&& value);
  #endif
  void set_userid_column(const char* value);
  void set_userid_column(const char* value, size_t size);
  ::std::string* mutable_userid_column();
  ::std::string* release_userid_column();
  void set_allocated_userid_column(::std::string* userid_column);

  // optional int64 expected_table_size_min = 1;
  bool has_expected_table_size_min() const;
  void clear_expected_table_size_min();
  static const int kExpectedTableSizeMinFieldNumber = 1;
  ::google::protobuf::int64 expected_table_size_min() const;
  void set_expected_table_size_min(::google::protobuf::int64 value);

  // optional int64 expected_table_size_max = 2;
  bool has_expected_table_size_max() const;
  void clear_expected_table_size_max();
  static const int kExpectedTableSizeMaxFieldNumber = 2;
  ::google::protobuf::int64 expected_table_size_max() const;
  void set_expected_table_size_max(::google::protobuf::int64 value);

  // optional double nullable_probability = 4;
  bool has_nullable_probability() const;
  void clear_nullable_probability();
  static const int kNullableProbabilityFieldNumber = 4;
  double nullable_probability() const;
  void set_nullable_probability(double value);

  // optional bool is_value_table = 3;
  bool has_is_value_table() const;
  void clear_is_value_table();
  static const int kIsValueTableFieldNumber = 3;
  bool is_value_table() const;
  void set_is_value_table(bool value);

  // @@protoc_insertion_point(class_scope:zetasql.TestTableOptionsProto)
 private:
  void set_has_expected_table_size_min();
  void clear_has_expected_table_size_min();
  void set_has_expected_table_size_max();
  void clear_has_expected_table_size_max();
  void set_has_is_value_table();
  void clear_has_is_value_table();
  void set_has_nullable_probability();
  void clear_has_nullable_probability();
  void set_has_userid_column();
  void clear_has_userid_column();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> required_features_;
  ::google::protobuf::RepeatedPtrField< ::zetasql::AnnotationMapProto > column_annotations_;
  ::google::protobuf::internal::ArenaStringPtr userid_column_;
  ::google::protobuf::int64 expected_table_size_min_;
  ::google::protobuf::int64 expected_table_size_max_;
  double nullable_probability_;
  bool is_value_table_;
  friend struct ::protobuf_zetasql_2fcompliance_2ftest_5fdriver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestTableProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.TestTableProto) */ {
 public:
  TestTableProto();
  virtual ~TestTableProto();

  TestTableProto(const TestTableProto& from);

  inline TestTableProto& operator=(const TestTableProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestTableProto(TestTableProto&& from) noexcept
    : TestTableProto() {
    *this = ::std::move(from);
  }

  inline TestTableProto& operator=(TestTableProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestTableProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestTableProto* internal_default_instance() {
    return reinterpret_cast<const TestTableProto*>(
               &_TestTableProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TestTableProto* other);
  friend void swap(TestTableProto& a, TestTableProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestTableProto* New() const final {
    return CreateMaybeMessage<TestTableProto>(NULL);
  }

  TestTableProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestTableProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestTableProto& from);
  void MergeFrom(const TestTableProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestTableProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .zetasql.TypeAndValue contents = 2;
  bool has_contents() const;
  void clear_contents();
  static const int kContentsFieldNumber = 2;
  private:
  const ::zetasql::TypeAndValue& _internal_contents() const;
  public:
  const ::zetasql::TypeAndValue& contents() const;
  ::zetasql::TypeAndValue* release_contents();
  ::zetasql::TypeAndValue* mutable_contents();
  void set_allocated_contents(::zetasql::TypeAndValue* contents);

  // optional .zetasql.TestTableOptionsProto options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  private:
  const ::zetasql::TestTableOptionsProto& _internal_options() const;
  public:
  const ::zetasql::TestTableOptionsProto& options() const;
  ::zetasql::TestTableOptionsProto* release_options();
  ::zetasql::TestTableOptionsProto* mutable_options();
  void set_allocated_options(::zetasql::TestTableOptionsProto* options);

  // @@protoc_insertion_point(class_scope:zetasql.TestTableProto)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_contents();
  void clear_has_contents();
  void set_has_options();
  void clear_has_options();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::zetasql::TypeAndValue* contents_;
  ::zetasql::TestTableOptionsProto* options_;
  friend struct ::protobuf_zetasql_2fcompliance_2ftest_5fdriver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TypeAndValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zetasql.TypeAndValue) */ {
 public:
  TypeAndValue();
  virtual ~TypeAndValue();

  TypeAndValue(const TypeAndValue& from);

  inline TypeAndValue& operator=(const TypeAndValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TypeAndValue(TypeAndValue&& from) noexcept
    : TypeAndValue() {
    *this = ::std::move(from);
  }

  inline TypeAndValue& operator=(TypeAndValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeAndValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TypeAndValue* internal_default_instance() {
    return reinterpret_cast<const TypeAndValue*>(
               &_TypeAndValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TypeAndValue* other);
  friend void swap(TypeAndValue& a, TypeAndValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TypeAndValue* New() const final {
    return CreateMaybeMessage<TypeAndValue>(NULL);
  }

  TypeAndValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TypeAndValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TypeAndValue& from);
  void MergeFrom(const TypeAndValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TypeAndValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zetasql.ValueProto value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::zetasql::ValueProto& _internal_value() const;
  public:
  const ::zetasql::ValueProto& value() const;
  ::zetasql::ValueProto* release_value();
  ::zetasql::ValueProto* mutable_value();
  void set_allocated_value(::zetasql::ValueProto* value);

  // optional .zetasql.TypeProto type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::zetasql::TypeProto& _internal_type() const;
  public:
  const ::zetasql::TypeProto& type() const;
  ::zetasql::TypeProto* release_type();
  ::zetasql::TypeProto* mutable_type();
  void set_allocated_type(::zetasql::TypeProto* type);

  // @@protoc_insertion_point(class_scope:zetasql.TypeAndValue)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::zetasql::ValueProto* value_;
  ::zetasql::TypeProto* type_;
  friend struct ::protobuf_zetasql_2fcompliance_2ftest_5fdriver_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TestDatabaseProto

// repeated string proto_files = 1;
inline int TestDatabaseProto::proto_files_size() const {
  return proto_files_.size();
}
inline void TestDatabaseProto::clear_proto_files() {
  proto_files_.Clear();
}
inline const ::std::string& TestDatabaseProto::proto_files(int index) const {
  // @@protoc_insertion_point(field_get:zetasql.TestDatabaseProto.proto_files)
  return proto_files_.Get(index);
}
inline ::std::string* TestDatabaseProto::mutable_proto_files(int index) {
  // @@protoc_insertion_point(field_mutable:zetasql.TestDatabaseProto.proto_files)
  return proto_files_.Mutable(index);
}
inline void TestDatabaseProto::set_proto_files(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zetasql.TestDatabaseProto.proto_files)
  proto_files_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TestDatabaseProto::set_proto_files(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:zetasql.TestDatabaseProto.proto_files)
  proto_files_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TestDatabaseProto::set_proto_files(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  proto_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zetasql.TestDatabaseProto.proto_files)
}
inline void TestDatabaseProto::set_proto_files(int index, const char* value, size_t size) {
  proto_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zetasql.TestDatabaseProto.proto_files)
}
inline ::std::string* TestDatabaseProto::add_proto_files() {
  // @@protoc_insertion_point(field_add_mutable:zetasql.TestDatabaseProto.proto_files)
  return proto_files_.Add();
}
inline void TestDatabaseProto::add_proto_files(const ::std::string& value) {
  proto_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zetasql.TestDatabaseProto.proto_files)
}
#if LANG_CXX11
inline void TestDatabaseProto::add_proto_files(::std::string&& value) {
  proto_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zetasql.TestDatabaseProto.proto_files)
}
#endif
inline void TestDatabaseProto::add_proto_files(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  proto_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zetasql.TestDatabaseProto.proto_files)
}
inline void TestDatabaseProto::add_proto_files(const char* value, size_t size) {
  proto_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zetasql.TestDatabaseProto.proto_files)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TestDatabaseProto::proto_files() const {
  // @@protoc_insertion_point(field_list:zetasql.TestDatabaseProto.proto_files)
  return proto_files_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TestDatabaseProto::mutable_proto_files() {
  // @@protoc_insertion_point(field_mutable_list:zetasql.TestDatabaseProto.proto_files)
  return &proto_files_;
}

// optional bool runs_as_test = 2;
inline bool TestDatabaseProto::has_runs_as_test() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestDatabaseProto::set_has_runs_as_test() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestDatabaseProto::clear_has_runs_as_test() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestDatabaseProto::clear_runs_as_test() {
  runs_as_test_ = false;
  clear_has_runs_as_test();
}
inline bool TestDatabaseProto::runs_as_test() const {
  // @@protoc_insertion_point(field_get:zetasql.TestDatabaseProto.runs_as_test)
  return runs_as_test_;
}
inline void TestDatabaseProto::set_runs_as_test(bool value) {
  set_has_runs_as_test();
  runs_as_test_ = value;
  // @@protoc_insertion_point(field_set:zetasql.TestDatabaseProto.runs_as_test)
}

// repeated string proto_names = 3;
inline int TestDatabaseProto::proto_names_size() const {
  return proto_names_.size();
}
inline void TestDatabaseProto::clear_proto_names() {
  proto_names_.Clear();
}
inline const ::std::string& TestDatabaseProto::proto_names(int index) const {
  // @@protoc_insertion_point(field_get:zetasql.TestDatabaseProto.proto_names)
  return proto_names_.Get(index);
}
inline ::std::string* TestDatabaseProto::mutable_proto_names(int index) {
  // @@protoc_insertion_point(field_mutable:zetasql.TestDatabaseProto.proto_names)
  return proto_names_.Mutable(index);
}
inline void TestDatabaseProto::set_proto_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zetasql.TestDatabaseProto.proto_names)
  proto_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TestDatabaseProto::set_proto_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:zetasql.TestDatabaseProto.proto_names)
  proto_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TestDatabaseProto::set_proto_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  proto_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zetasql.TestDatabaseProto.proto_names)
}
inline void TestDatabaseProto::set_proto_names(int index, const char* value, size_t size) {
  proto_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zetasql.TestDatabaseProto.proto_names)
}
inline ::std::string* TestDatabaseProto::add_proto_names() {
  // @@protoc_insertion_point(field_add_mutable:zetasql.TestDatabaseProto.proto_names)
  return proto_names_.Add();
}
inline void TestDatabaseProto::add_proto_names(const ::std::string& value) {
  proto_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zetasql.TestDatabaseProto.proto_names)
}
#if LANG_CXX11
inline void TestDatabaseProto::add_proto_names(::std::string&& value) {
  proto_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zetasql.TestDatabaseProto.proto_names)
}
#endif
inline void TestDatabaseProto::add_proto_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  proto_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zetasql.TestDatabaseProto.proto_names)
}
inline void TestDatabaseProto::add_proto_names(const char* value, size_t size) {
  proto_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zetasql.TestDatabaseProto.proto_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TestDatabaseProto::proto_names() const {
  // @@protoc_insertion_point(field_list:zetasql.TestDatabaseProto.proto_names)
  return proto_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TestDatabaseProto::mutable_proto_names() {
  // @@protoc_insertion_point(field_mutable_list:zetasql.TestDatabaseProto.proto_names)
  return &proto_names_;
}

// repeated string enum_names = 4;
inline int TestDatabaseProto::enum_names_size() const {
  return enum_names_.size();
}
inline void TestDatabaseProto::clear_enum_names() {
  enum_names_.Clear();
}
inline const ::std::string& TestDatabaseProto::enum_names(int index) const {
  // @@protoc_insertion_point(field_get:zetasql.TestDatabaseProto.enum_names)
  return enum_names_.Get(index);
}
inline ::std::string* TestDatabaseProto::mutable_enum_names(int index) {
  // @@protoc_insertion_point(field_mutable:zetasql.TestDatabaseProto.enum_names)
  return enum_names_.Mutable(index);
}
inline void TestDatabaseProto::set_enum_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zetasql.TestDatabaseProto.enum_names)
  enum_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TestDatabaseProto::set_enum_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:zetasql.TestDatabaseProto.enum_names)
  enum_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TestDatabaseProto::set_enum_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  enum_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zetasql.TestDatabaseProto.enum_names)
}
inline void TestDatabaseProto::set_enum_names(int index, const char* value, size_t size) {
  enum_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zetasql.TestDatabaseProto.enum_names)
}
inline ::std::string* TestDatabaseProto::add_enum_names() {
  // @@protoc_insertion_point(field_add_mutable:zetasql.TestDatabaseProto.enum_names)
  return enum_names_.Add();
}
inline void TestDatabaseProto::add_enum_names(const ::std::string& value) {
  enum_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zetasql.TestDatabaseProto.enum_names)
}
#if LANG_CXX11
inline void TestDatabaseProto::add_enum_names(::std::string&& value) {
  enum_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:zetasql.TestDatabaseProto.enum_names)
}
#endif
inline void TestDatabaseProto::add_enum_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  enum_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zetasql.TestDatabaseProto.enum_names)
}
inline void TestDatabaseProto::add_enum_names(const char* value, size_t size) {
  enum_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zetasql.TestDatabaseProto.enum_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TestDatabaseProto::enum_names() const {
  // @@protoc_insertion_point(field_list:zetasql.TestDatabaseProto.enum_names)
  return enum_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TestDatabaseProto::mutable_enum_names() {
  // @@protoc_insertion_point(field_mutable_list:zetasql.TestDatabaseProto.enum_names)
  return &enum_names_;
}

// repeated .zetasql.TestTableProto test_tables = 5;
inline int TestDatabaseProto::test_tables_size() const {
  return test_tables_.size();
}
inline void TestDatabaseProto::clear_test_tables() {
  test_tables_.Clear();
}
inline ::zetasql::TestTableProto* TestDatabaseProto::mutable_test_tables(int index) {
  // @@protoc_insertion_point(field_mutable:zetasql.TestDatabaseProto.test_tables)
  return test_tables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zetasql::TestTableProto >*
TestDatabaseProto::mutable_test_tables() {
  // @@protoc_insertion_point(field_mutable_list:zetasql.TestDatabaseProto.test_tables)
  return &test_tables_;
}
inline const ::zetasql::TestTableProto& TestDatabaseProto::test_tables(int index) const {
  // @@protoc_insertion_point(field_get:zetasql.TestDatabaseProto.test_tables)
  return test_tables_.Get(index);
}
inline ::zetasql::TestTableProto* TestDatabaseProto::add_test_tables() {
  // @@protoc_insertion_point(field_add:zetasql.TestDatabaseProto.test_tables)
  return test_tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zetasql::TestTableProto >&
TestDatabaseProto::test_tables() const {
  // @@protoc_insertion_point(field_list:zetasql.TestDatabaseProto.test_tables)
  return test_tables_;
}

// -------------------------------------------------------------------

// TestTableOptionsProto

// optional int64 expected_table_size_min = 1;
inline bool TestTableOptionsProto::has_expected_table_size_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestTableOptionsProto::set_has_expected_table_size_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestTableOptionsProto::clear_has_expected_table_size_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestTableOptionsProto::clear_expected_table_size_min() {
  expected_table_size_min_ = GOOGLE_LONGLONG(0);
  clear_has_expected_table_size_min();
}
inline ::google::protobuf::int64 TestTableOptionsProto::expected_table_size_min() const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableOptionsProto.expected_table_size_min)
  return expected_table_size_min_;
}
inline void TestTableOptionsProto::set_expected_table_size_min(::google::protobuf::int64 value) {
  set_has_expected_table_size_min();
  expected_table_size_min_ = value;
  // @@protoc_insertion_point(field_set:zetasql.TestTableOptionsProto.expected_table_size_min)
}

// optional int64 expected_table_size_max = 2;
inline bool TestTableOptionsProto::has_expected_table_size_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestTableOptionsProto::set_has_expected_table_size_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestTableOptionsProto::clear_has_expected_table_size_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestTableOptionsProto::clear_expected_table_size_max() {
  expected_table_size_max_ = GOOGLE_LONGLONG(0);
  clear_has_expected_table_size_max();
}
inline ::google::protobuf::int64 TestTableOptionsProto::expected_table_size_max() const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableOptionsProto.expected_table_size_max)
  return expected_table_size_max_;
}
inline void TestTableOptionsProto::set_expected_table_size_max(::google::protobuf::int64 value) {
  set_has_expected_table_size_max();
  expected_table_size_max_ = value;
  // @@protoc_insertion_point(field_set:zetasql.TestTableOptionsProto.expected_table_size_max)
}

// optional bool is_value_table = 3;
inline bool TestTableOptionsProto::has_is_value_table() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestTableOptionsProto::set_has_is_value_table() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestTableOptionsProto::clear_has_is_value_table() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestTableOptionsProto::clear_is_value_table() {
  is_value_table_ = false;
  clear_has_is_value_table();
}
inline bool TestTableOptionsProto::is_value_table() const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableOptionsProto.is_value_table)
  return is_value_table_;
}
inline void TestTableOptionsProto::set_is_value_table(bool value) {
  set_has_is_value_table();
  is_value_table_ = value;
  // @@protoc_insertion_point(field_set:zetasql.TestTableOptionsProto.is_value_table)
}

// optional double nullable_probability = 4;
inline bool TestTableOptionsProto::has_nullable_probability() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestTableOptionsProto::set_has_nullable_probability() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestTableOptionsProto::clear_has_nullable_probability() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestTableOptionsProto::clear_nullable_probability() {
  nullable_probability_ = 0;
  clear_has_nullable_probability();
}
inline double TestTableOptionsProto::nullable_probability() const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableOptionsProto.nullable_probability)
  return nullable_probability_;
}
inline void TestTableOptionsProto::set_nullable_probability(double value) {
  set_has_nullable_probability();
  nullable_probability_ = value;
  // @@protoc_insertion_point(field_set:zetasql.TestTableOptionsProto.nullable_probability)
}

// repeated .zetasql.LanguageFeature required_features = 5;
inline int TestTableOptionsProto::required_features_size() const {
  return required_features_.size();
}
inline void TestTableOptionsProto::clear_required_features() {
  required_features_.Clear();
}
inline ::zetasql::LanguageFeature TestTableOptionsProto::required_features(int index) const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableOptionsProto.required_features)
  return static_cast< ::zetasql::LanguageFeature >(required_features_.Get(index));
}
inline void TestTableOptionsProto::set_required_features(int index, ::zetasql::LanguageFeature value) {
  assert(::zetasql::LanguageFeature_IsValid(value));
  required_features_.Set(index, value);
  // @@protoc_insertion_point(field_set:zetasql.TestTableOptionsProto.required_features)
}
inline void TestTableOptionsProto::add_required_features(::zetasql::LanguageFeature value) {
  assert(::zetasql::LanguageFeature_IsValid(value));
  required_features_.Add(value);
  // @@protoc_insertion_point(field_add:zetasql.TestTableOptionsProto.required_features)
}
inline const ::google::protobuf::RepeatedField<int>&
TestTableOptionsProto::required_features() const {
  // @@protoc_insertion_point(field_list:zetasql.TestTableOptionsProto.required_features)
  return required_features_;
}
inline ::google::protobuf::RepeatedField<int>*
TestTableOptionsProto::mutable_required_features() {
  // @@protoc_insertion_point(field_mutable_list:zetasql.TestTableOptionsProto.required_features)
  return &required_features_;
}

// optional string userid_column = 6;
inline bool TestTableOptionsProto::has_userid_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestTableOptionsProto::set_has_userid_column() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestTableOptionsProto::clear_has_userid_column() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestTableOptionsProto::clear_userid_column() {
  userid_column_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid_column();
}
inline const ::std::string& TestTableOptionsProto::userid_column() const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableOptionsProto.userid_column)
  return userid_column_.GetNoArena();
}
inline void TestTableOptionsProto::set_userid_column(const ::std::string& value) {
  set_has_userid_column();
  userid_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zetasql.TestTableOptionsProto.userid_column)
}
#if LANG_CXX11
inline void TestTableOptionsProto::set_userid_column(::std::string&& value) {
  set_has_userid_column();
  userid_column_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zetasql.TestTableOptionsProto.userid_column)
}
#endif
inline void TestTableOptionsProto::set_userid_column(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid_column();
  userid_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zetasql.TestTableOptionsProto.userid_column)
}
inline void TestTableOptionsProto::set_userid_column(const char* value, size_t size) {
  set_has_userid_column();
  userid_column_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zetasql.TestTableOptionsProto.userid_column)
}
inline ::std::string* TestTableOptionsProto::mutable_userid_column() {
  set_has_userid_column();
  // @@protoc_insertion_point(field_mutable:zetasql.TestTableOptionsProto.userid_column)
  return userid_column_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestTableOptionsProto::release_userid_column() {
  // @@protoc_insertion_point(field_release:zetasql.TestTableOptionsProto.userid_column)
  if (!has_userid_column()) {
    return NULL;
  }
  clear_has_userid_column();
  return userid_column_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestTableOptionsProto::set_allocated_userid_column(::std::string* userid_column) {
  if (userid_column != NULL) {
    set_has_userid_column();
  } else {
    clear_has_userid_column();
  }
  userid_column_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid_column);
  // @@protoc_insertion_point(field_set_allocated:zetasql.TestTableOptionsProto.userid_column)
}

// repeated .zetasql.AnnotationMapProto column_annotations = 7;
inline int TestTableOptionsProto::column_annotations_size() const {
  return column_annotations_.size();
}
inline ::zetasql::AnnotationMapProto* TestTableOptionsProto::mutable_column_annotations(int index) {
  // @@protoc_insertion_point(field_mutable:zetasql.TestTableOptionsProto.column_annotations)
  return column_annotations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::zetasql::AnnotationMapProto >*
TestTableOptionsProto::mutable_column_annotations() {
  // @@protoc_insertion_point(field_mutable_list:zetasql.TestTableOptionsProto.column_annotations)
  return &column_annotations_;
}
inline const ::zetasql::AnnotationMapProto& TestTableOptionsProto::column_annotations(int index) const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableOptionsProto.column_annotations)
  return column_annotations_.Get(index);
}
inline ::zetasql::AnnotationMapProto* TestTableOptionsProto::add_column_annotations() {
  // @@protoc_insertion_point(field_add:zetasql.TestTableOptionsProto.column_annotations)
  return column_annotations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zetasql::AnnotationMapProto >&
TestTableOptionsProto::column_annotations() const {
  // @@protoc_insertion_point(field_list:zetasql.TestTableOptionsProto.column_annotations)
  return column_annotations_;
}

// -------------------------------------------------------------------

// TestTableProto

// optional string name = 1;
inline bool TestTableProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestTableProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestTableProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestTableProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TestTableProto::name() const {
  // @@protoc_insertion_point(field_get:zetasql.TestTableProto.name)
  return name_.GetNoArena();
}
inline void TestTableProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zetasql.TestTableProto.name)
}
#if LANG_CXX11
inline void TestTableProto::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zetasql.TestTableProto.name)
}
#endif
inline void TestTableProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zetasql.TestTableProto.name)
}
inline void TestTableProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zetasql.TestTableProto.name)
}
inline ::std::string* TestTableProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:zetasql.TestTableProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestTableProto::release_name() {
  // @@protoc_insertion_point(field_release:zetasql.TestTableProto.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestTableProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:zetasql.TestTableProto.name)
}

// optional .zetasql.TypeAndValue contents = 2;
inline bool TestTableProto::has_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestTableProto::set_has_contents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestTableProto::clear_has_contents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestTableProto::clear_contents() {
  if (contents_ != NULL) contents_->Clear();
  clear_has_contents();
}
inline const ::zetasql::TypeAndValue& TestTableProto::_internal_contents() const {
  return *contents_;
}
inline const ::zetasql::TypeAndValue& TestTableProto::contents() const {
  const ::zetasql::TypeAndValue* p = contents_;
  // @@protoc_insertion_point(field_get:zetasql.TestTableProto.contents)
  return p != NULL ? *p : *reinterpret_cast<const ::zetasql::TypeAndValue*>(
      &::zetasql::_TypeAndValue_default_instance_);
}
inline ::zetasql::TypeAndValue* TestTableProto::release_contents() {
  // @@protoc_insertion_point(field_release:zetasql.TestTableProto.contents)
  clear_has_contents();
  ::zetasql::TypeAndValue* temp = contents_;
  contents_ = NULL;
  return temp;
}
inline ::zetasql::TypeAndValue* TestTableProto::mutable_contents() {
  set_has_contents();
  if (contents_ == NULL) {
    auto* p = CreateMaybeMessage<::zetasql::TypeAndValue>(GetArenaNoVirtual());
    contents_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zetasql.TestTableProto.contents)
  return contents_;
}
inline void TestTableProto::set_allocated_contents(::zetasql::TypeAndValue* contents) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contents_;
  }
  if (contents) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contents = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contents, submessage_arena);
    }
    set_has_contents();
  } else {
    clear_has_contents();
  }
  contents_ = contents;
  // @@protoc_insertion_point(field_set_allocated:zetasql.TestTableProto.contents)
}

// optional .zetasql.TestTableOptionsProto options = 3;
inline bool TestTableProto::has_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestTableProto::set_has_options() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestTableProto::clear_has_options() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestTableProto::clear_options() {
  if (options_ != NULL) options_->Clear();
  clear_has_options();
}
inline const ::zetasql::TestTableOptionsProto& TestTableProto::_internal_options() const {
  return *options_;
}
inline const ::zetasql::TestTableOptionsProto& TestTableProto::options() const {
  const ::zetasql::TestTableOptionsProto* p = options_;
  // @@protoc_insertion_point(field_get:zetasql.TestTableProto.options)
  return p != NULL ? *p : *reinterpret_cast<const ::zetasql::TestTableOptionsProto*>(
      &::zetasql::_TestTableOptionsProto_default_instance_);
}
inline ::zetasql::TestTableOptionsProto* TestTableProto::release_options() {
  // @@protoc_insertion_point(field_release:zetasql.TestTableProto.options)
  clear_has_options();
  ::zetasql::TestTableOptionsProto* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::zetasql::TestTableOptionsProto* TestTableProto::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::zetasql::TestTableOptionsProto>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zetasql.TestTableProto.options)
  return options_;
}
inline void TestTableProto::set_allocated_options(::zetasql::TestTableOptionsProto* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    set_has_options();
  } else {
    clear_has_options();
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:zetasql.TestTableProto.options)
}

// -------------------------------------------------------------------

// TypeAndValue

// optional .zetasql.ValueProto value = 1;
inline bool TypeAndValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypeAndValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TypeAndValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::zetasql::ValueProto& TypeAndValue::_internal_value() const {
  return *value_;
}
inline const ::zetasql::ValueProto& TypeAndValue::value() const {
  const ::zetasql::ValueProto* p = value_;
  // @@protoc_insertion_point(field_get:zetasql.TypeAndValue.value)
  return p != NULL ? *p : *reinterpret_cast<const ::zetasql::ValueProto*>(
      &::zetasql::_ValueProto_default_instance_);
}
inline ::zetasql::ValueProto* TypeAndValue::release_value() {
  // @@protoc_insertion_point(field_release:zetasql.TypeAndValue.value)
  clear_has_value();
  ::zetasql::ValueProto* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::zetasql::ValueProto* TypeAndValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::zetasql::ValueProto>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zetasql.TypeAndValue.value)
  return value_;
}
inline void TypeAndValue::set_allocated_value(::zetasql::ValueProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:zetasql.TypeAndValue.value)
}

// optional .zetasql.TypeProto type = 2;
inline bool TypeAndValue::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TypeAndValue::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TypeAndValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::zetasql::TypeProto& TypeAndValue::_internal_type() const {
  return *type_;
}
inline const ::zetasql::TypeProto& TypeAndValue::type() const {
  const ::zetasql::TypeProto* p = type_;
  // @@protoc_insertion_point(field_get:zetasql.TypeAndValue.type)
  return p != NULL ? *p : *reinterpret_cast<const ::zetasql::TypeProto*>(
      &::zetasql::_TypeProto_default_instance_);
}
inline ::zetasql::TypeProto* TypeAndValue::release_type() {
  // @@protoc_insertion_point(field_release:zetasql.TypeAndValue.type)
  clear_has_type();
  ::zetasql::TypeProto* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::zetasql::TypeProto* TypeAndValue::mutable_type() {
  set_has_type();
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::zetasql::TypeProto>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:zetasql.TypeAndValue.type)
  return type_;
}
inline void TypeAndValue::set_allocated_type(::zetasql::TypeProto* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(type)->GetArena();
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    set_has_type();
  } else {
    clear_has_type();
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:zetasql.TypeAndValue.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace zetasql

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_zetasql_2fcompliance_2ftest_5fdriver_2eproto
